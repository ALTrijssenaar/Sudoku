# research.md

Decision: Technology Stack

- Choice: .NET 8 Web API (ASP.NET Core) with EF Core and Npgsql for PostgreSQL
- Rationale: .NET 8 provides a stable, performant server platform with first-class Web API support, built-in DI, minimal hosting model, and excellent tooling on Windows. EF Core + Npgsql is the standard path for PostgreSQL persistence in .NET projects.
- Alternatives considered: Node.js/Express with Sequelize/TypeORM, Python FastAPI with SQLAlchemy. Rejected due to team familiarity and desire for strong typing and tooling.

Decision: Authentication

- Choice: JWT bearer tokens for stateless API authentication
- Rationale: Works well for SPAs and mobile clients; easy to integrate in ASP.NET Core with JwtBearer middleware; compatible with token refresh patterns.
- Alternatives: Cookie-based sessions (better for traditional web apps) or OAuth/OIDC (more complex, recommended when integrating external identity providers). For MVP, JWT is preferred.

Decision: Puzzle representation

- Choice: JSONB 81-int array in Postgres for `initial_cells`, `solution` and `current_state`
- Rationale: JSONB provides flexibility, easy to query, and keeps board logic simple. Use constraints/trigger or app-side validation to ensure shape.
- Alternatives: Normalized relational tables for cells (too verbose); compressed string representation (less readable for debugging).

Decision: Difficulty mapping

- Choice: Easy/Medium/Hard mapped by givens count and heuristic difficulty scoring.
- Rationale: Simple and standard for MVP. Document exact mapping in code and tests.

Decision: Single-solution vs multiple-solution puzzles

- Choice: Prefer single-solution puzzles for user experience; allow multi-solution only if difficulty mapping requires it and it's documented.
- Rationale: Solvers and validation are simpler and user expectations align with single-solution puzzles.

Decision: API contract format

- Choice: OpenAPI (Swagger) auto-generated by Swashbuckle for ASP.NET Core
- Rationale: Built-in support in ASP.NET Core; gives interactive documentation and client generation capabilities.

Decision: Local dev database

- Choice: Docker Compose with official postgres image, persistent volume for data
- Rationale: Reproducible dev environment and CI parity.


---

Research tasks (Phase 0 outputs)

- Puzzle generator libraries/patterns for .NET and heuristics for difficulty scoring
- EF Core JSONB mapping best practices and indexing considerations for JSONB arrays
- JWT token refresh patterns and security recommendations (refresh tokens vs short-lived tokens)
- Swagger/Swashbuckle integration best practices for versioning and auth

For each research task, implement short experiments or test code during Phase 1 where appropriate.

*** End of research.md
